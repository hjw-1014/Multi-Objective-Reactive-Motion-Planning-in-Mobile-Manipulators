import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

"""
Plotting tools for Sampling-based algorithms
@author: huiming zhou
"""

import matplotlib.pyplot as plt
import matplotlib.patches as patches
import os
import sys

sys.path.append(os.path.dirname(os.path.abspath(__file__)) +
                "/../../Sampling_based_Planning/")

class Plotting:
    def __init__(self, x_start, x_goal):
        self.xI, self.xG = x_start, x_goal

    def animation(self, nodelist, path, animation=False):
        self.plot_visited(nodelist, animation)
        self.plot_path(path)

    def animation_connect(self, V1, V2, path):
        self.plot_visited_connect(V1, V2)
        self.plot_path(path)

    @staticmethod
    def plot_visited(nodelist, animation):
        if animation:
            count = 0
            for node in nodelist:
                count += 1
                if node.parent:
                    plt.plot([node.parent.x, node.x], [node.parent.y, node.y], "-g")
                    plt.gcf().canvas.mpl_connect('key_release_event',
                                                 lambda event:
                                                 [exit(0) if event.key == 'escape' else None])
                    if count % 10 == 0:
                        plt.pause(0.001)
        else:
            for node in nodelist:
                if node.parent:
                    plt.plot([node.parent.x, node.x], [node.parent.y, node.y], "-g")

    @staticmethod
    def plot_visited_connect(V1, V2):
        len1, len2 = len(V1), len(V2)

        for k in range(max(len1, len2)):
            if k < len1:
                if V1[k].parent:
                    plt.plot([V1[k].x, V1[k].parent.x], [V1[k].y, V1[k].parent.y], "-g")
            if k < len2:
                if V2[k].parent:
                    plt.plot([V2[k].x, V2[k].parent.x], [V2[k].y, V2[k].parent.y], "-g")

            plt.gcf().canvas.mpl_connect('key_release_event',
                                         lambda event: [exit(0) if event.key == 'escape' else None])

            if k % 2 == 0:
                plt.pause(0.001)

        plt.pause(0.01)

    @staticmethod
    def plot_path(path):
        if len(path) != 0:
            plt.plot([x[0] for x in path], [x[1] for x in path], '-r', linewidth=2)
            plt.pause(0.01)
        plt.show()


def plot_moveit_traj(xy_traj: list):
    '''
        Plot the path which is generated by RRTstar in MoveIt
    '''

    lenth = len(xy_traj)

    fig, ax = plt.subplots()
    center_size = 10
    marker_size = 5000

    for i in range(lenth):
        ax.scatter(xy_traj[i][0], xy_traj[i][1], s=center_size, alpha=1)
        ax.scatter(xy_traj[i][0], xy_traj[i][1], s=marker_size, alpha=.05)
        ax.plot(xy_traj[i][0], xy_traj[i][1])

    ax.grid(True)

    ax.set_xlim(-0.5, 1.5)
    ax.set_ylim(-0.5, 1.5)

    box_center_x = 0.5
    box_center_y = 0.5
    ax.text(box_center_x, box_center_y, "box")

    left, bottom, width, height = (0.35, 0.35, 0.3, 0.3)
    ax.add_patch(Rectangle((left, bottom), width, height,
                           facecolor="black", alpha=0.5))

    plt.show()


def plot_multiple_cascade_trajectories(whole_cascade_control_path):
    '''
        Plot many cascade paths which are generated by the algorithm
    '''

    fig, ax = plt.subplots()
    for cascade_control_path in whole_cascade_control_path:

        lenth = len(cascade_control_path)

        center_size = 5
        marker_size = 5000

        for i in range(lenth):
            ax.scatter(cascade_control_path[i][0], cascade_control_path[i][1], s=center_size, alpha=1)
        # ax.scatter(cascade_control_path[i][0], cascade_control_path[i][1], s=marker_size, alpha=.05) # TODO: For base
        # ax.plot(self.cascade_control_path[i][0], self.cascade_control_path[i][1])

    # x_traj = [0] * num_path_points
    # y_traj = [0] * num_path_points
    # for j in range(num_path_points):
    #     x_traj[j] = xy_traj[j][0]
    #     y_traj[j] = xy_traj[j][1]

    # ax.plot(x_traj, y_traj, 'C3', lw=1.)

    ax.grid(True)

    ax.set_xlim(-1.5, 1.5)
    ax.set_ylim(-1.5, 1.5)

    box_center_x = 0.5
    box_center_y = 0.5
    ax.text(box_center_x, box_center_y, "box")

    left, bottom, width, height = (0.35, 0.35, 0.3, 0.3)
    ax.add_patch(Rectangle((left, bottom), width, height, facecolor="black", alpha=0.5))

    plt.show()


def plot_cascade_control_traj(cascade_control_path, xy_traj, num_path_points):
    '''
        Plot the cascade path which is generated by the algorithm
    '''
    cascade_control_path = cascade_control_path
    lenth = len(cascade_control_path)

    fig, ax = plt.subplots()
    center_size = 10
    marker_size = 5000

    xy_traj = xy_traj
    x_traj = [0] * num_path_points
    y_traj = [0] * num_path_points

    for i in range(lenth):
        ax.scatter(cascade_control_path[i][0], cascade_control_path[i][1], s=center_size, alpha=1)
        ax.scatter(cascade_control_path[i][0], cascade_control_path[i][1], s=marker_size, alpha=.05)

    for j in range(num_path_points):
        x_traj[j] = xy_traj[j][0]
        y_traj[j] = xy_traj[j][1]

    ax.plot(x_traj, y_traj, 'C3', lw=1.)

    ax.grid(True)

    ax.set_xlim(-0.5, 1.5)
    ax.set_ylim(-0.5, 1.5)

    box_center_x = 0.5
    box_center_y = 0.5
    ax.text(box_center_x, box_center_y, "box")

    left, bottom, width, height = (0.35, 0.35, 0.3, 0.3)
    ax.add_patch(Rectangle((left, bottom), width, height,
                           facecolor="black", alpha=0.5))

    plt.show()


def plot_vector_field_in_arrows(self):  # TODO: add on 07.22
    '''
        Plot the vector field using arrows
    '''

    fig, ax = plt.subplots()  # TODO: Initialize fig

    whole_cascade_control_path = self.whole_cascade_control_path
    num_paths = len(whole_cascade_control_path)
    round_whole_paths = self.round_path_position_values(2)
    velocity_matrix = self.transform_path_2_velocity_matrix()

    assert len(round_whole_paths) == len(velocity_matrix), "Dimension of path != Dimension of velocity path"

    for i in range(len(round_whole_paths)):
        cur_path = round_whole_paths[i]
        cur_vel_path = velocity_matrix[i]
        assert len(cur_path) == len(cur_vel_path), "Dimension of cur_path != Dimension of cur_vel_path"
        for j in range(len(cur_path)):
            cur_point = cur_path[j]
            cur_vel = cur_vel_path[j]
            cur_x = cur_point[0]
            cur_y = cur_point[1]
            cur_vel_x = cur_vel[0]
            cur_vel_y = cur_vel[1]
            ax.arrow(cur_x, cur_y, cur_vel_x, cur_vel_y, width=0.00001, head_width=0.025, head_length=0.05, color='g')
        print("### Draw vector field in arrows ###")

    ax.set_title('Vector field in arrows')
    ax.grid(True)

    ax.set_xlim(-1.5, 1.5)
    ax.set_ylim(-1.5, 1.5)

    xy_traj = self.xy_traj
    x_traj = [0] * self.num_path_points
    y_traj = [0] * self.num_path_points
    for j in range(self.num_path_points):
        x_traj[j] = xy_traj[j][0]
        y_traj[j] = xy_traj[j][1]

    ax.plot(x_traj, y_traj, 'C3', lw=2.)  # TODO: Draw the groud truth path generated by MoveIt

    box_center_x = 0.5
    box_center_y = 0.5
    # ax.text(box_center_x, box_center_y, "box")

    left, bottom, width, height = (0.35, 0.35, 0.3, 0.3)
    ax.add_patch(Rectangle((left, bottom), width, height, facecolor="black", alpha=0.5))  # TODO: Draw the box

    plt.show()