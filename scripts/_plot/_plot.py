import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

def plot_moveit_traj(self, xy_traj: list):
    '''
        Plot the path which is generated by RRTstar in MoveIt
    '''

    lenth = len(xy_traj)

    fig, ax = plt.subplots()
    center_size = 10
    marker_size = 5000

    for i in range(lenth):
        ax.scatter(xy_traj[i][0], xy_traj[i][1], s=center_size, alpha=1)
        ax.scatter(xy_traj[i][0], xy_traj[i][1], s=marker_size, alpha=.05)
        ax.plot(xy_traj[i][0], xy_traj[i][1])

    ax.grid(True)

    ax.set_xlim(-0.5, 1.5)
    ax.set_ylim(-0.5, 1.5)

    box_center_x = 0.5
    box_center_y = 0.5
    ax.text(box_center_x, box_center_y, "box")

    left, bottom, width, height = (0.35, 0.35, 0.3, 0.3)
    ax.add_patch(Rectangle((left, bottom), width, height,
                           facecolor="black", alpha=0.5))

    plt.show()


def plot_multiple_cascade_trajectories(self):
    '''
        Plot many cascade paths which are generated by the algorithm
    '''

    whole_cascade_control_path = self.whole_cascade_control_path

    fig, ax = plt.subplots()
    for cascade_control_path in whole_cascade_control_path:

        lenth = len(cascade_control_path)

        center_size = 5
        marker_size = 5000

        for i in range(lenth):
            ax.scatter(cascade_control_path[i][0], cascade_control_path[i][1], s=center_size, alpha=1)
        # ax.scatter(cascade_control_path[i][0], cascade_control_path[i][1], s=marker_size, alpha=.05) # TODO: For base
        # ax.plot(self.cascade_control_path[i][0], self.cascade_control_path[i][1])

    # ax.scatter(x_traj, y_traj, c="tab:blue", s=center_size, label="tab:blue", alpha=1)
    # ax.scatter(x_traj, y_traj, c="tab:green", s=marker_size,  label="tab:green", alpha=.05)
    # ax.legend('')

    xy_traj = self.xy_traj
    x_traj = [0] * self.num_path_points
    y_traj = [0] * self.num_path_points
    for j in range(self.num_path_points):
        x_traj[j] = xy_traj[j][0]
        y_traj[j] = xy_traj[j][1]

    ax.plot(x_traj, y_traj, 'C3', lw=1.)

    ax.grid(True)

    ax.set_xlim(-1.5, 1.5)
    ax.set_ylim(-1.5, 1.5)

    box_center_x = 0.5
    box_center_y = 0.5
    ax.text(box_center_x, box_center_y, "box")

    left, bottom, width, height = (0.35, 0.35, 0.3, 0.3)
    ax.add_patch(Rectangle((left, bottom), width, height, facecolor="black", alpha=0.5))

    plt.show()


def plot_cascade_control_traj(self):
    '''
        Plot the cascade path which is generated by the algorithm
    '''
    cascade_control_path = self.cascade_control_path
    lenth = len(cascade_control_path)

    fig, ax = plt.subplots()
    center_size = 10
    marker_size = 5000

    xy_traj = self.xy_traj
    x_traj = [0] * self.num_path_points
    y_traj = [0] * self.num_path_points

    for i in range(lenth):
        ax.scatter(cascade_control_path[i][0], cascade_control_path[i][1], s=center_size, alpha=1)
        ax.scatter(cascade_control_path[i][0], cascade_control_path[i][1], s=marker_size, alpha=.05)
    # ax.plot(self.cascade_control_path[i][0], self.cascade_control_path[i][1])

    # ax.scatter(x_traj, y_traj, c="tab:blue", s=center_size, label="tab:blue", alpha=1)
    # ax.scatter(x_traj, y_traj, c="tab:green", s=marker_size,  label="tab:green", alpha=.05)
    # ax.legend('')

    for j in range(self.num_path_points):
        x_traj[j] = xy_traj[j][0]
        y_traj[j] = xy_traj[j][1]

    ax.plot(x_traj, y_traj, 'C3', lw=1.)

    ax.grid(True)

    ax.set_xlim(-0.5, 1.5)
    ax.set_ylim(-0.5, 1.5)

    box_center_x = 0.5
    box_center_y = 0.5
    ax.text(box_center_x, box_center_y, "box")

    left, bottom, width, height = (0.35, 0.35, 0.3, 0.3)
    ax.add_patch(Rectangle((left, bottom), width, height,
                           facecolor="black", alpha=0.5))

    plt.show()


def plot_vector_field_in_arrows(self):  # TODO: add on 07.22
    '''
        Plot the vector field using arrows
    '''

    fig, ax = plt.subplots()  # TODO: Initialize fig

    whole_cascade_control_path = self.whole_cascade_control_path
    num_paths = len(whole_cascade_control_path)
    round_whole_paths = self.round_path_position_values(2)
    velocity_matrix = self.transform_path_2_velocity_matrix()

    assert len(round_whole_paths) == len(velocity_matrix), "Dimension of path != Dimension of velocity path"

    for i in range(len(round_whole_paths)):
        cur_path = round_whole_paths[i]
        cur_vel_path = velocity_matrix[i]
        assert len(cur_path) == len(cur_vel_path), "Dimension of cur_path != Dimension of cur_vel_path"
        for j in range(len(cur_path)):
            cur_point = cur_path[j]
            cur_vel = cur_vel_path[j]
            cur_x = cur_point[0]
            cur_y = cur_point[1]
            cur_vel_x = cur_vel[0]
            cur_vel_y = cur_vel[1]
            ax.arrow(cur_x, cur_y, cur_vel_x, cur_vel_y, width=0.00001, head_width=0.025, head_length=0.05, color='g')
        print("### Draw vector field in arrows ###")

    ax.set_title('Vector field in arrows')
    ax.grid(True)

    ax.set_xlim(-1.5, 1.5)
    ax.set_ylim(-1.5, 1.5)

    xy_traj = self.xy_traj
    x_traj = [0] * self.num_path_points
    y_traj = [0] * self.num_path_points
    for j in range(self.num_path_points):
        x_traj[j] = xy_traj[j][0]
        y_traj[j] = xy_traj[j][1]

    ax.plot(x_traj, y_traj, 'C3', lw=2.)  # TODO: Draw the groud truth path generated by MoveIt

    box_center_x = 0.5
    box_center_y = 0.5
    # ax.text(box_center_x, box_center_y, "box")

    left, bottom, width, height = (0.35, 0.35, 0.3, 0.3)
    ax.add_patch(Rectangle((left, bottom), width, height, facecolor="black", alpha=0.5))  # TODO: Draw the box

    plt.show()