###
import numpy as np
import math
from copy import deepcopy
from icecream import ic

def compute_current_distance_from_path_points(self, current_state) -> list:
    '''
        return the distances between current position and all the points of the path
    '''

    xy_traj = self.xy_traj
    cur_positon = current_state[0]

    current_distances_from_path_points = []

    for i in range(len(xy_traj)):
        dist = self.compute_euclidean_distance(cur_positon, xy_traj[i])
        current_distances_from_path_points.append(dist)

    return current_distances_from_path_points


def compute_current_distance_from_path_points_viz(self, cur_position: list) -> list:  # TODO: add on 07.24

    '''
        return the distances between current position and all the points of the path
    '''

    xy_traj = self.xy_traj

    current_distances_from_path_points = []

    for i in range(len(xy_traj)):
        dist = self.compute_euclidean_distance(cur_position, xy_traj[i])
        current_distances_from_path_points.append(dist)

    return current_distances_from_path_points


def compute_euclidean_distance(self, first_point: list, second_point: list) -> float:
    '''
        return: the euclidean distance between two points
    '''

    assert len(first_point) == len(second_point), "ERROR: Two points have different dimension!!!"

    dist = 0
    for i in range(len(first_point)):
        dist += pow((first_point[i] - second_point[i]), 2)

    return math.sqrt(dist)


def choose_min_dist_point(self, current_distances_from_path_points: list) -> (float, int):
    '''
        Firstly, check if this point is already close enough to the end point.
        if not:
            Choose the closest distance and its index from the given list, this list contains
            the distances of between a known point and all the points of the path (generated by RRTstar)
            if the distance is smaller than self.cascade_threshold:
                go to the next point until bigger than self.cascade_threshold or close enough to the end point
        if yes:
            return the last point of the path
    '''
    if not self.check_arrive():

        # current_distances_sorted = sorted(current_distances_from_path_points)
        min_dist = min(current_distances_from_path_points)
        # ic(min_dist)
        # ic(current_distances_from_path_points[-1])
        min_dist_index = current_distances_from_path_points.index(min_dist)
        # ic(min_dist_index)

        idx = 1
        while min_dist < self.cascade_threshold and not self.check_arrive():  # TODO: ERROR -> Get stuck here!!! FIXED 0720
            min_dist_index += 1
            # ic(min_dist_index)

            if min_dist_index == self.num_path_points:
                return min_dist, min_dist_index - 1

            min_dist = current_distances_from_path_points[min_dist_index]
        # ic(min_dist)
        # if min_dist < self.cascade_threshold:

        # idx += 1
        # min_dist_index = current_distances_from_path_points.index(min_dist)

        return min_dist, min_dist_index

    else:
        return self.end_point_threshold, self.num_path_points - 1


def choose_min_dist_point_viz_vector(self, current_distances_from_path_points: list) -> (
float, int):  # TODO: add on 07.24
    '''
        Choose the closest distance and its index from the given list, this list contains
        the distances of between a known point and all the points of the path (generated by RRTstar)
    '''
    min_dist = min(current_distances_from_path_points)
    min_dist_index = current_distances_from_path_points.index(min_dist)

    return min_dist, min_dist_index  # TODO: add


def compute_repulsive_potential_force(self, current_position) -> list:  # TODO: 07.24
    '''
        Compute repulsive force for current position
    '''
    cur_dist = self.compute_euclidean_distance(current_position, self.box_position)
    cur_dist_arr = np.clip(np.asarray(cur_dist), a_min=self.end_point_threshold, a_max=float('inf'))
    cur_dist_clip = cur_dist_arr.tolist()
    gradient = [0] * len(current_position)
    for i in range(len(current_position)):
        gradient[i] = current_position[i] - self.box_position[i]

    repulsive_force = [0] * len(current_position)
    if cur_dist > self.repulsive_threshold:
        return [0, 0]
    else:
        for j in range(len(current_position)):
            repulsive_force[j] = self.repulsive_scale * (1. / self.repulsive_threshold - 1. / cur_dist_clip) * (
                        cur_dist ** 2) * gradient[j]
        return repulsive_force


def compute_attractive_potential_force(self, current_position, closest_point) -> list:  # TODO 0724
    cur_dist = self.compute_euclidean_distance(current_position, self.box_position)
    attractive_force = [0] * len(current_position)

    for i in range(len(current_position)):
        attractive_force[i] = -self.k_d * (current_position[i] - closest_point[i])

    return attractive_force


def round_path_position_values(self, num: int) -> list:  # TODO: set num to 2
    '''
        Round the position values to 0.01
    '''
    whole_cascade_control_path = deepcopy(self.whole_cascade_control_path)
    num_paths = len(whole_cascade_control_path)

    for i in range(num_paths):
        cur_path = whole_cascade_control_path[i]
        for pos in cur_path:
            for j in range(self.dim_xy):
                pos[j] = round(pos[j], num)

    round_whole_paths = whole_cascade_control_path
    self.round_whole_paths = round_whole_paths

    return round_whole_paths


def transform_path_2_velocity_matrix(self) -> list:
    '''
        transform the rounded path to velocity path
    '''
    round_whole_paths = deepcopy(self.round_whole_paths)
    num_paths = len(round_whole_paths)

    for i in range(num_paths):
        cur_path = round_whole_paths[i]
        len_cur_path = len(cur_path)
        for j in range(len_cur_path - 1):
            cur_path[j][0] = cur_path[j + 1][0] - cur_path[j][0]
            cur_path[j][1] = cur_path[j + 1][1] - cur_path[j][1]
        cur_path[len_cur_path - 1][0] = 0.
        cur_path[len_cur_path - 1][1] = 0.

    velocity_matrix = round_whole_paths
    self.velocity_matrix = velocity_matrix

    return velocity_matrix


def velocity_matrix_2_UV(self) -> list:
    '''
        transform the velocity path to U and V. U, V -> np.array((301, 301))
    '''
    # U = np.zeros((n, n))
    # V = np.zeros((n, n))
    U_list = []
    V_list = []

    round_whole_paths = deepcopy(self.round_whole_paths)
    velocity_matrix = deepcopy(self.velocity_matrix)

    num_paths = len(velocity_matrix)

    for n in range(num_paths):
        cur_vel_path = velocity_matrix[n]
        cur_path = round_whole_paths[n]

        len_cur_path = len(cur_path)
        len_cur_vel_path = len(cur_vel_path)

        assert len_cur_vel_path == len_cur_path, "ERROR: current velocity dimension doesn't match path's dimension"

        U = np.zeros((self.grid_number, self.grid_number))
        V = np.zeros((self.grid_number, self.grid_number))

        U = np.ones((self.grid_number, self.grid_number)) * 0.
        V = np.ones((self.grid_number, self.grid_number)) * 0.
        for i in range(int(self.grid_number / 2)):
            V[i][0] = 0.1

        for k in range(len_cur_path - 1):
            ic(k)
            cur_point = cur_path[k]
            cur_vel = cur_vel_path[k]
            # Get the position x and y in the map
            x = cur_point[0]
            y = cur_point[1]
            x_i = int((x - self.grid_map_min) * self.grid_step_reciprocal)
            y_j = int((y - self.grid_map_min) * self.grid_step_reciprocal)

            # Velocity for visualization
            ic(x_i)
            ic(y_j)
            U[x_i][y_j] = cur_vel[0]
            V[x_i][y_j] = cur_vel[1]
            ic(U[x_i][y_j])
            ic(V[x_i][y_j])

        U_list.append(U)
        V_list.append(V)

    return U_list, V_list